<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Milo å¦å…‹å¤§æˆ° (ç¶“å…¸å¾©åˆ»ç‰ˆ)</title>
    <style>
        body {
            background-color: #222;
            color: white;
            font-family: 'Courier New', Courier, monospace; /* å¾©å¤å­—é«” */
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            overscroll-behavior: none; 
            user-select: none;
            -webkit-user-select: none;
        }
        h1 { 
            font-size: 24px; 
            text-shadow: 2px 2px #000;
            color: #e69138;
            margin: 5px 0; 
        }
        
        #game-wrapper {
            position: relative;
            width: 100%;
            max-width: 520px; /* èª¿æ•´ç‚ºæ¥è¿‘åŸç‰ˆæ¯”ä¾‹ */
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #000;
            border: 4px solid #666;
        }

        canvas {
            background-color: #000;
            display: block;
            width: 100%; 
            touch-action: none; 
            image-rendering: pixelated; /* è®“ç¹ªåœ–å‘ˆç¾åƒç´ é¢¨ */
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            z-index: 10;
        }
        #ui-layer.active { display: flex; }
        
        /* è™›æ“¬æŒ‰éµ */
        #mobile-controls {
            display: flex;
            width: 100%;
            justify-content: space-between;
            margin-top: 15px;
            max-width: 520px;
            padding: 0 10px;
            box-sizing: border-box;
        }

        .d-pad {
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 50px 50px;
            gap: 5px;
            align-items: center;
            justify-items: center;
        }

        .control-btn {
            width: 50px; height: 50px;
            background: #555;
            border: 2px solid #888;
            border-radius: 8px; /* æ–¹å½¢åœ“è§’æ›´æœ‰å¾©å¤æ„Ÿ */
            color: white;
            font-size: 20px;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 4px 0 #333;
            cursor: pointer;
            touch-action: manipulation; 
        }
        .control-btn:active, .control-btn.pressed {
            background: #777;
            transform: translateY(4px);
            box-shadow: 0 0 0 #333;
        }

        #btn-up { grid-column: 2; grid-row: 1; }
        #btn-left { grid-column: 1; grid-row: 2; }
        #btn-down { grid-column: 2; grid-row: 2; }
        #btn-right { grid-column: 3; grid-row: 2; }

        #fire-btn {
            width: 80px; height: 80px;
            background: #b71c1c;
            border: 2px solid #e57373;
            border-radius: 50%;
            font-weight: bold;
            display: flex; justify-content: center; align-items: center;
            align-self: center;
            box-shadow: 0 5px 0 #7f0000;
        }
        #fire-btn:active, #fire-btn.pressed {
            transform: translateY(5px);
            box-shadow: 0 0 0 #7f0000;
        }

        /* è¼¸å…¥æ¡†èˆ‡æ’è¡Œæ¦œ */
        input { 
            padding: 10px; font-size: 16px; border: 2px solid #e69138; 
            background: #222; color: white; width: 70%; text-align: center; font-family: 'Courier New';
        }
        button.game-btn { 
            padding: 12px 24px; font-size: 18px; background: #e69138; color: black; 
            border: none; margin-top: 15px; font-family: 'Courier New'; font-weight: bold; cursor: pointer;
        }
        button.game-btn:disabled { background: #888; }

        #leaderboard {
            margin-top: 20px; width: 100%; max-width: 520px;
            background: #333; padding: 10px; border: 2px solid #555; box-sizing: border-box;
        }
        .score-row { display: flex; justify-content: space-between; border-bottom: 1px dashed #555; padding: 8px 0; color: #ccc; }
        .score-row:first-child { color: #ffd700; font-weight: bold; } /* ç¬¬ä¸€åé‡‘è‰² */
    </style>
</head>
<body>

    <h1>Milo TANK 1990</h1>
    
    <div id="game-wrapper">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui-layer" class="active">
            <h2 id="status-text" style="color:#e69138">STAGE 1</h2>
            <h3 id="final-score" style="display:none">SCORE: 0</h3>
            
            <div id="input-area" style="display:none; text-align:center; width: 100%;">
                <input type="text" id="player-name" placeholder="ENTER NAME" maxlength="8">
                <br>
                <button id="save-btn" class="game-btn">SAVE SCORE</button>
            </div>
            
            <button id="start-btn" class="game-btn">START GAME</button>
        </div>
    </div>

    <div id="mobile-controls">
        <div class="d-pad">
            <div id="btn-up" class="control-btn" data-key="ArrowUp">â–²</div>
            <div id="btn-left" class="control-btn" data-key="ArrowLeft">â—€</div>
            <div id="btn-down" class="control-btn" data-key="ArrowDown">â–¼</div>
            <div id="btn-right" class="control-btn" data-key="ArrowRight">â–¶</div>
        </div>
        <div id="fire-btn" class="control-btn" data-key="Space">FIRE</div>
    </div>

    <div id="leaderboard">
        <h3>ğŸ† HIGH SCORES</h3>
        <div id="score-list">LOADING...</div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDcHWsk6ffYC1XyKIga8GpHok_jUyPcNQc",
            authDomain: "milo-game-d238c.firebaseapp.com",
            projectId: "milo-game-d238c",
            storageBucket: "milo-game-d238c.firebasestorage.app",
            messagingSenderId: "64418915608",
            appId: "1:64418915608:web:7a4c51bab0afcad8756a6d"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // --- éŠæˆ²æ ¸å¿ƒé‚è¼¯ ---

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const BLOCK_SIZE = 32; // æ¯å€‹æ ¼å­çš„æ¨™æº–å¤§å° (é¡ä¼¼ 16x16 æ”¾å¤§)
        
        function resizeCanvas() {
            const maxWidth = 520;
            const containerWidth = Math.min(window.innerWidth - 20, maxWidth);
            // è®“å¯¬åº¦æ˜¯ BLOCK_SIZE çš„å€æ•¸ï¼Œé¿å…ç ´åœ–
            const cols = Math.floor(containerWidth / BLOCK_SIZE);
            canvas.width = cols * BLOCK_SIZE;
            canvas.height = canvas.width; // æ­£æ–¹å½¢åœ°åœ–
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // UI å…ƒç´ 
        const uiLayer = document.getElementById('ui-layer');
        const startBtn = document.getElementById('start-btn');
        const saveBtn = document.getElementById('save-btn');
        const statusText = document.getElementById('status-text');
        const inputArea = document.getElementById('input-area');
        const finalScoreText = document.getElementById('final-score');
        const playerNameInput = document.getElementById('player-name');

        let gameRunning = false;
        let score = 0;
        let animationId;
        let frameCount = 0;

        // éŠæˆ²ç‰©ä»¶
        let player;
        let bullets = [];
        let enemies = [];
        let walls = [];
        let base = {};
        let enemySpawnTimer = 0;

        // æ–¹å‘å¸¸æ•¸
        const DIR = { UP: 0, RIGHT: 1, DOWN: 2, LEFT: 3 };

        // åˆå§‹åŒ–éŠæˆ²
        function resetGame() {
            const size = canvas.width / 13; // 13x13 æ ¼å­
            
            // ç©å®¶èµ·å§‹ä½ç½® (è€é·¹å·¦å´)
            player = { 
                x: size * 4, y: canvas.height - size, 
                size: size, speed: size * 0.1, 
                dir: DIR.UP, moving: false,
                color: '#e69138' // ç¶“å…¸é»ƒè‰² P1
            };

            // åŸºåœ° (è€é·¹)
            base = {
                x: canvas.width / 2 - size / 2,
                y: canvas.height - size,
                size: size,
                alive: true
            };

            bullets = [];
            enemies = [];
            walls = [];
            score = 0;
            enemySpawnTimer = 0;

            // ç”Ÿæˆåœ°åœ– (ç°¡å–®çš„ç£šå¡Šé™£åˆ—)
            createMap(size);
        }

        function createMap(size) {
            // åœç¹åŸºåœ°çš„ç‰†
            walls.push({x: base.x - size, y: base.y, size: size, type: 'brick'});
            walls.push({x: base.x - size, y: base.y - size, size: size, type: 'brick'});
            walls.push({x: base.x, y: base.y - size, size: size, type: 'brick'});
            walls.push({x: base.x + size, y: base.y - size, size: size, type: 'brick'});
            walls.push({x: base.x + size, y: base.y, size: size, type: 'brick'});

            // éš¨æ©Ÿç”Ÿæˆä¸€äº›éšœç¤™ç‰©
            for(let i=0; i<20; i++) {
                let wx = Math.floor(Math.random() * 13) * size;
                let wy = Math.floor(Math.random() * 10) * size; // ä¸ç”Ÿæˆåœ¨æœ€åº•éƒ¨
                // é¿å…ç”Ÿæˆåœ¨å‡ºç”Ÿé»
                if (wy < size * 2) continue; 
                walls.push({x: wx, y: wy, size: size, type: 'brick'});
            }
        }

        // æŒ‰éµè™•ç†
        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.key] = true;
            if (e.code === 'Space' && gameRunning) shoot(player);
        });
        window.addEventListener('keyup', e => keys[e.key] = false);

        // æ‰‹æ©Ÿè™›æ“¬æŒ‰éµ
        document.querySelectorAll('.control-btn').forEach(btn => {
            const handlePress = (e) => {
                e.preventDefault();
                const key = btn.getAttribute('data-key');
                keys[key] = true;
                btn.classList.add('pressed');
                if (key === 'Space' && gameRunning) shoot(player);
            };
            const handleRelease = (e) => {
                e.preventDefault();
                keys[btn.getAttribute('data-key')] = false;
                btn.classList.remove('pressed');
            };
            btn.addEventListener('touchstart', handlePress, {passive: false});
            btn.addEventListener('touchend', handleRelease, {passive: false});
            btn.addEventListener('mousedown', handlePress);
            btn.addEventListener('mouseup', handleRelease);
        });

        // å°„æ“Šé‚è¼¯ (ç¾åœ¨æ”¯æ´æ–¹å‘)
        function shoot(shooter) {
            // é™åˆ¶å­å½ˆæ•¸é‡ (ç•«é¢åªèƒ½æœ‰ä¸€ç™¼)
            const myBullets = bullets.filter(b => b.owner === (shooter === player ? 'player' : 'enemy'));
            if (myBullets.length > 0 && shooter === player) return; 

            let bx = shooter.x + shooter.size/2 - 3;
            let by = shooter.y + shooter.size/2 - 3;
            let vx = 0, vy = 0;
            const bSpeed = shooter.size * 0.25;

            if (shooter.dir === DIR.UP) vy = -bSpeed;
            if (shooter.dir === DIR.DOWN) vy = bSpeed;
            if (shooter.dir === DIR.LEFT) vx = -bSpeed;
            if (shooter.dir === DIR.RIGHT) vx = bSpeed;

            bullets.push({ 
                x: bx, y: by, size: 6, 
                vx: vx, vy: vy, 
                owner: shooter === player ? 'player' : 'enemy' 
            });
        }

        function spawnEnemy() {
            const size = player.size;
            // éš¨æ©Ÿå¾ä¸Šæ–¹ä¸‰å€‹é»å‡ºç”Ÿ
            const positions = [0, canvas.width/2 - size/2, canvas.width - size];
            const x = positions[Math.floor(Math.random() * 3)];
            
            enemies.push({ 
                x: x, y: 0, size: size, 
                speed: size * 0.05, 
                dir: DIR.DOWN,
                moveTimer: 0,
                color: '#cccccc' // éŠ€è‰²æ•µäºº
            });
        }

        // ç¹ªåœ–å‡½æ•¸ï¼šç•«å¦å…‹ (Pixel Art é¢¨æ ¼)
        function drawTank(ctx, tank) {
            ctx.fillStyle = tank.color;
            const s = tank.size;
            const x = tank.x;
            const y = tank.y;

            // å±¥å¸¶
            ctx.fillStyle = '#000'; // å±¥å¸¶åº•è‰²
            if (tank.dir === DIR.UP || tank.dir === DIR.DOWN) {
                ctx.fillRect(x, y, s*0.25, s); // å·¦
                ctx.fillRect(x + s*0.75, y, s*0.25, s); // å³
                
                // å±¥å¸¶ç´°ç¯€ (æ»¾å‹•æ•ˆæœ)
                ctx.fillStyle = '#555'; 
                const offset = (Math.floor(frameCount / 10) % 2) * (s/4);
                for(let i=0; i<4; i++) {
                    ctx.fillRect(x, y + i*(s/4), s*0.25, 2);
                    ctx.fillRect(x + s*0.75, y + i*(s/4), s*0.25, 2);
                }
            } else {
                ctx.fillRect(x, y, s, s*0.25); // ä¸Š
                ctx.fillRect(x, y + s*0.75, s, s*0.25); // ä¸‹
                ctx.fillStyle = '#555'; 
                for(let i=0; i<4; i++) {
                    ctx.fillRect(x + i*(s/4), y, 2, s*0.25);
                    ctx.fillRect(x + i*(s/4), y + s*0.75, 2, s*0.25);
                }
            }

            // è»Šèº«
            ctx.fillStyle = tank.color;
            ctx.fillRect(x + s*0.25, y + s*0.25, s*0.5, s*0.5);

            // ç ²å¡”
            ctx.fillStyle = tank.owner === 'player' ? '#b7950b' : '#999'; 
            ctx.fillRect(x + s*0.35, y + s*0.35, s*0.3, s*0.3);

            // ç ²ç®¡
            ctx.fillStyle = '#ccc';
            const barrelL = s * 0.4;
            const barrelW = s * 0.1;
            const cx = x + s/2;
            const cy = y + s/2;
            
            if (tank.dir === DIR.UP) ctx.fillRect(cx - barrelW/2, cy - barrelL, barrelW, barrelL);
            if (tank.dir === DIR.DOWN) ctx.fillRect(cx - barrelW/2, cy, barrelW, barrelL);
            if (tank.dir === DIR.LEFT) ctx.fillRect(cx - barrelL, cy - barrelW/2, barrelL, barrelW);
            if (tank.dir === DIR.RIGHT) ctx.fillRect(cx, cy - barrelW/2, barrelL, barrelW);
        }

        // ç•«åŸºåœ°
        function drawBase(ctx) {
            if (!base.alive) {
                // çˆ†ç‚¸å¾Œçš„åŸºåœ°
                ctx.fillStyle = '#555';
                ctx.fillRect(base.x, base.y, base.size, base.size);
                return;
            }
            // ç•«è€é·¹
            const x = base.x, y = base.y, s = base.size;
            ctx.fillStyle = '#444'; // èƒŒæ™¯
            ctx.fillRect(x, y, s, s);
            ctx.fillStyle = '#b71c1c'; // é·¹èº«
            ctx.beginPath();
            ctx.moveTo(x + s/2, y + 5);
            ctx.lineTo(x + 5, y + s - 5);
            ctx.lineTo(x + s - 5, y + s - 5);
            ctx.fill();
        }

        function update() {
            frameCount++;

            // 1. ç©å®¶ç§»å‹•
            let nextX = player.x;
            let nextY = player.y;
            player.moving = false;

            if (keys['ArrowUp']) { player.dir = DIR.UP; nextY -= player.speed; player.moving = true; }
            else if (keys['ArrowDown']) { player.dir = DIR.DOWN; nextY += player.speed; player.moving = true; }
            else if (keys['ArrowLeft']) { player.dir = DIR.LEFT; nextX -= player.speed; player.moving = true; }
            else if (keys['ArrowRight']) { player.dir = DIR.RIGHT; nextX += player.speed; player.moving = true; }

            // ç©å®¶ç¢°æ’æª¢æ¸¬ (ç‰†å£ & é‚Šç•Œ)
            if (player.moving && !checkWallCollision(nextX, nextY, player.size)) {
                player.x = nextX;
                player.y = nextY;
            }

            // 2. å­å½ˆæ›´æ–°
            bullets.forEach((b, index) => {
                b.x += b.vx;
                b.y += b.vy;

                // é‚Šç•Œç§»é™¤
                if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
                    bullets.splice(index, 1);
                    return;
                }

                // å­å½ˆæ‰“ç‰†å£
                for (let i = 0; i < walls.length; i++) {
                    if (rectIntersect(b, walls[i])) {
                        walls.splice(i, 1); // ç ´å£ç‰†å£
                        bullets.splice(index, 1); // å­å½ˆæ¶ˆå¤±
                        return;
                    }
                }

                // å­å½ˆæ‰“åŸºåœ°
                if (base.alive && rectIntersect(b, base)) {
                    base.alive = false;
                    gameOver();
                }
            });

            // 3. æ•µäºº AI èˆ‡æ›´æ–°
            enemySpawnTimer++;
            if (enemySpawnTimer > 150) { // ç´„ 2.5 ç§’ä¸€éš»
                spawnEnemy();
                enemySpawnTimer = 0;
            }

            enemies.forEach((e, eIndex) => {
                // ç°¡å–® AI: éš¨æ©Ÿè½‰å‘
                e.moveTimer++;
                if (e.moveTimer > 60) {
                    e.dir = Math.floor(Math.random() * 4);
                    e.moveTimer = 0;
                    // å¶çˆ¾å°„æ“Š
                    if (Math.random() > 0.5) shoot(e);
                }

                let ex = e.x;
                let ey = e.y;
                if (e.dir === DIR.UP) ey -= e.speed;
                if (e.dir === DIR.DOWN) ey += e.speed;
                if (e.dir === DIR.LEFT) ex -= e.speed;
                if (e.dir === DIR.RIGHT) ex += e.speed;

                // æ•µäººæ’ç‰†å‰‡åœæ­¢
                if (!checkWallCollision(ex, ey, e.size)) {
                    e.x = ex;
                    e.y = ey;
                }

                // ç©å®¶å­å½ˆæ‰“æ•µäºº
                bullets.forEach((b, bIndex) => {
                    if (b.owner === 'player' && rectIntersect(b, e)) {
                        enemies.splice(eIndex, 1);
                        bullets.splice(bIndex, 1);
                        score += 100;
                    }
                });
                
                // æ•µäººå­å½ˆæ‰“ç©å®¶
                bullets.forEach((b, bIndex) => {
                    if (b.owner === 'enemy' && rectIntersect(b, player)) {
                        gameOver();
                    }
                });

                // æ•µäººæ’ç©å®¶
                if (rectIntersect(player, e)) gameOver();
            });
        }

        function checkWallCollision(x, y, size) {
            // æª¢æŸ¥é‚Šç•Œ
            if (x < 0 || x + size > canvas.width || y < 0 || y + size > canvas.height) return true;
            
            // æª¢æŸ¥ç‰†å£
            const rect = {x: x, y: y, size: size}; // ç°¡åŒ–
            for (let w of walls) {
                // ä½¿ç”¨ç¨å¾®å¯¬é¬†çš„ç¢°æ’ç¸®æ¸›ä¸€é»é«”ç©ï¼Œé¿å…å¡ä½
                if (rectIntersect(rect, w, 2)) return true;
            }
            // æª¢æŸ¥åŸºåœ°
            if (base.alive && rectIntersect(rect, base)) return true;
            
            return false;
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawBase(ctx);

            // ç•«ç‰†å£
            ctx.fillStyle = '#b71c1c'; // ç£šç´…
            walls.forEach(w => {
                ctx.fillRect(w.x + 2, w.y + 2, w.size - 4, w.size - 4);
                // ç£šå¡Šç´‹è·¯
                ctx.fillStyle = '#d32f2f';
                ctx.fillRect(w.x + 4, w.y + 4, w.size/2 - 4, w.size/2 - 4);
                ctx.fillStyle = '#b71c1c';
            });

            drawTank(ctx, player);
            enemies.forEach(e => drawTank(ctx, e));

            ctx.fillStyle = 'white';
            bullets.forEach(b => ctx.fillRect(b.x, b.y, b.size, b.size));

            // UI æ–‡å­—
            ctx.fillStyle = 'white';
            ctx.font = '20px "Courier New"';
            ctx.fillText(`SCORE: ${score}`, 10, 25);
        }

        function animate() {
            if (!gameRunning) return;
            update();
            draw();
            animationId = requestAnimationFrame(animate);
        }

        function gameOver() {
            if(!gameRunning) return;
            gameRunning = false;
            cancelAnimationFrame(animationId);
            
            statusText.innerText = "GAME OVER";
            statusText.style.color = "#d32f2f";
            finalScoreText.innerText = `SCORE: ${score}`;
            finalScoreText.style.display = 'block';
            inputArea.style.display = 'block';
            startBtn.style.display = 'none';
            uiLayer.classList.add('active');
        }

        // ç¢°æ’æª¢æ¸¬ (padding ç”¨ä¾†æ¸›å°‘é«”ç©ï¼Œè®“è½‰å½é †æš¢)
        function rectIntersect(r1, r2, padding = 0) {
            const p = padding;
            return !(r2.x + p > r1.x + r1.size - p || 
                     r2.x + r2.size - p < r1.x + p || 
                     r2.y + p > r1.y + r1.size - p || 
                     r2.y + r2.size - p < r1.y + p);
        }

        // --- Firebase æ“ä½œ (ç¶­æŒä¸è®Š) ---
        startBtn.addEventListener('click', () => {
            resetGame();
            gameRunning = true;
            uiLayer.classList.remove('active');
            inputArea.style.display = 'none';
            finalScoreText.style.display = 'none';
            animate();
        });

        saveBtn.addEventListener('click', async () => {
            const name = playerNameInput.value || "UNKNOWN";
            saveBtn.disabled = true; saveBtn.innerText = "SAVING...";
            try {
                await addDoc(collection(db, "leaderboard"), {
                    name: name, score: score, date: new Date()
                });
                loadLeaderboard();
                saveBtn.disabled = false; saveBtn.innerText = "SAVE SCORE";
                statusText.innerText = "STAGE 1"; statusText.style.color = "#e69138";
                startBtn.style.display = 'block'; inputArea.style.display = 'none';
            } catch(e) { alert("Error: " + e.message); saveBtn.disabled = false; }
        });

        async function loadLeaderboard() {
            const listDiv = document.getElementById('score-list');
            try {
                const q = query(collection(db, "leaderboard"), orderBy("score", "desc"), limit(5));
                const querySnapshot = await getDocs(q);
                let html = "";
                querySnapshot.forEach((doc) => {
                    const d = doc.data();
                    html += `<div class="score-row"><span>${d.name}</span><span>${d.score}</span></div>`;
                });
                listDiv.innerHTML = html || "NO DATA";
            } catch (e) { listDiv.innerHTML = "ERROR"; }
        }
        loadLeaderboard();

    </script>
</body>
</html>
