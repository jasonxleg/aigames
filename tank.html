<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Milo TANK 1990 (Fixed Input)</title>
    <style>
        /* 全域鎖定，防止畫面滑動 */
        html, body {
            position: fixed; 
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #111;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /* 預設禁止選取，但按鈕會覆蓋此設定 */
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; 
        }

        h1 {
            font-size: 20px;
            color: #e69138;
            margin: 5px 0;
            flex-shrink: 0;
            text-shadow: 2px 2px #000;
        }

        #game-wrapper {
            position: relative;
            background-color: #000;
            border: 4px solid #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            flex-shrink: 0; 
        }

        canvas {
            display: block;
            image-rendering: pixelated;
        }

        /* UI 層 - 確保 z-index 最高 */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            z-index: 100; /* 確保在最上層 */
        }
        #ui-layer.active { display: flex; }

        /* --- 修正重點：讓按鈕和輸入框可以被點擊 --- */
        input, button.game-btn {
            /* 允許原生的點擊和操作 */
            pointer-events: auto !important;
            touch-action: manipulation !important;
            z-index: 101; /* 比 UI 層更高 */
        }

        input { 
            padding: 10px; font-size: 16px; border: 2px solid #e69138; 
            background: #222; color: white; width: 60%; text-align: center; 
            font-family: 'Courier New'; margin-bottom: 10px;
            user-select: text !important; /* 允許輸入文字 */
            -webkit-user-select: text !important;
        }

        button.game-btn { 
            padding: 15px 30px; /* 加大按鈕點擊範圍 */
            font-size: 20px; 
            background: #e69138; color: black; 
            border: 2px solid #fff; 
            border-radius: 5px;
            margin-top: 15px; 
            font-family: 'Courier New'; 
            font-weight: bold; 
            cursor: pointer;
            box-shadow: 0 4px 0 #885500;
        }
        button.game-btn:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        /* 手機控制器 */
        #mobile-controls {
            display: flex;
            width: 100%;
            max-width: 500px;
            justify-content: space-between;
            padding: 10px 20px;
            box-sizing: border-box;
            flex-shrink: 0;
            margin-bottom: 10px;
        }

        .d-pad {
            display: grid;
            grid-template-columns: 50px 50px 50px;
            grid-template-rows: 45px 45px;
            gap: 5px;
        }

        .control-btn {
            background: #444; border: 2px solid #777; border-radius: 8px;
            color: #ccc; font-size: 20px;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 4px 0 #222; cursor: pointer;
            touch-action: none; /* 控制器保持不觸發原生行為 */
        }
        .control-btn:active, .control-btn.pressed {
            background: #666; transform: translateY(4px); box-shadow: none;
        }

        #btn-up { grid-column: 2; grid-row: 1; }
        #btn-left { grid-column: 1; grid-row: 2; }
        #btn-down { grid-column: 2; grid-row: 2; }
        #btn-right { grid-column: 3; grid-row: 2; }

        #fire-btn {
            width: 75px; height: 75px;
            border-radius: 50%; background: #b71c1c; border: 2px solid #e57373;
            color: white; font-weight: bold; display: flex; justify-content: center; align-items: center;
            box-shadow: 0 4px 0 #7f0000; align-self: center;
            touch-action: none;
        }
        #fire-btn:active, #fire-btn.pressed { transform: translateY(4px); box-shadow: none; }
        
        #leaderboard-overlay { margin-top: 15px; font-size: 14px; color: #ccc; text-align: center; }
    </style>
</head>
<body>

    <h1>Milo TANK 1990</h1>
    
    <div id="game-wrapper">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui-layer" class="active">
            <h2 id="status-text" style="color:#e69138; font-size:24px;">STAGE 1</h2>
            <h3 id="final-score" style="display:none">SCORE: 0</h3>
            
            <div id="input-area" style="display:none; text-align:center; width: 100%;">
                <input type="text" id="player-name" placeholder="YOUR NAME" maxlength="8">
                <br>
                <button id="save-btn" class="game-btn">SAVE SCORE</button>
            </div>
            
            <button id="start-btn" class="game-btn">START GAME</button>

            <div id="leaderboard-overlay">
                <p>--- TOP 3 ---</p>
                <div id="mini-leaderboard">Loading...</div>
            </div>
        </div>
    </div>

    <div id="mobile-controls">
        <div class="d-pad">
            <div id="btn-up" class="control-btn" data-key="ArrowUp">▲</div>
            <div id="btn-left" class="control-btn" data-key="ArrowLeft">◀</div>
            <div id="btn-down" class="control-btn" data-key="ArrowDown">▼</div>
            <div id="btn-right" class="control-btn" data-key="ArrowRight">▶</div>
        </div>
        <div id="fire-btn" class="control-btn" data-key="Space">FIRE</div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDcHWsk6ffYC1XyKIga8GpHok_jUyPcNQc",
            authDomain: "milo-game-d238c.firebaseapp.com",
            projectId: "milo-game-d238c",
            storageBucket: "milo-game-d238c.firebasestorage.app",
            messagingSenderId: "64418915608",
            appId: "1:64418915608:web:7a4c51bab0afcad8756a6d"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const BLOCK_SIZE = 32; 

        function resizeGame() {
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            const availableH = winH - 170; 
            const availableW = winW - 20; 
            let gameSize = Math.min(availableW, availableH);
            if (gameSize > 520) gameSize = 520;
            const cols = Math.floor(gameSize / BLOCK_SIZE);
            const finalSize = cols * BLOCK_SIZE;
            canvas.width = finalSize;
            canvas.height = finalSize;
            if (!gameRunning) {
                ctx.fillStyle = "#000";
                ctx.fillRect(0,0, canvas.width, canvas.height);
            }
        }
        resizeGame();
        window.addEventListener('resize', resizeGame);

        const uiLayer = document.getElementById('ui-layer');
        const startBtn = document.getElementById('start-btn');
        const saveBtn = document.getElementById('save-btn');
        const statusText = document.getElementById('status-text');
        const inputArea = document.getElementById('input-area');
        const finalScoreText = document.getElementById('final-score');
        const playerNameInput = document.getElementById('player-name');
        const miniLeaderboard = document.getElementById('mini-leaderboard');

        let gameRunning = false;
        let score = 0;
        let animationId;
        let frameCount = 0;
        let player, bullets=[], enemies=[], walls=[], base={}, enemySpawnTimer=0;
        const DIR = { UP: 0, RIGHT: 1, DOWN: 2, LEFT: 3 };
        const keys = {};

        function resetGame() {
            const size = canvas.width / 13; 
            player = { x: size * 4, y: canvas.height - size, size: size, speed: size * 0.1, dir: DIR.UP, moving: false, color: '#e69138' };
            base = { x: canvas.width / 2 - size / 2, y: canvas.height - size, size: size, alive: true };
            bullets = []; enemies = []; walls = []; score = 0; enemySpawnTimer = 0;
            createMap(size);
        }

        function createMap(size) {
            const mapW = [
                {x: base.x-size, y: base.y}, {x: base.x-size, y: base.y-size}, 
                {x: base.x, y: base.y-size}, {x: base.x+size, y: base.y-size}, {x: base.x+size, y: base.y}
            ];
            mapW.forEach(p => walls.push({...p, size: size}));

            for(let i=0; i<18; i++) {
                let wx = Math.floor(Math.random() * 13) * size;
                let wy = Math.floor(Math.random() * 10) * size;
                if (wy < size * 2) continue; 
                walls.push({x: wx, y: wy, size: size});
            }
        }

        // --- 修正：通用按鈕綁定函式 (支援 Touch 和 Click) ---
        function bindBtn(elem, callback) {
            // 防止重複觸發的旗標
            let triggered = false;

            const handler = (e) => {
                // 如果是觸控事件，阻止預設行為以避免點擊穿透，但允許按鈕本身的行為
                if(e.type === 'touchstart') {
                    e.stopPropagation();
                    // e.preventDefault(); // 註解掉，因為某些瀏覽器需要 preventDefault 才能阻擋滑鼠模擬，但也可能阻擋 input focus
                }
                
                if (!triggered) {
                    triggered = true;
                    callback();
                    // 300ms 後重置，避免連點太快
                    setTimeout(() => triggered = false, 300);
                }
            };

            // 綁定兩種事件確保一定會觸發
            elem.addEventListener('touchstart', handler, {passive: false});
            elem.addEventListener('click', handler);
        }

        // 綁定 Start 按鈕
        bindBtn(startBtn, () => {
            resetGame(); 
            gameRunning = true; 
            uiLayer.classList.remove('active');
            inputArea.style.display = 'none'; 
            finalScoreText.style.display = 'none'; 
            animate();
        });

        // 綁定 Save 按鈕
        bindBtn(saveBtn, async () => {
            const name = playerNameInput.value || "AAA";
            saveBtn.innerText = "...";
            try {
                await addDoc(collection(db, "leaderboard"), { name, score, date: new Date() });
                await loadLeaderboard();
                saveBtn.innerText = "SAVE OK"; 
                setTimeout(() => {
                    saveBtn.innerText = "SAVE SCORE";
                    statusText.innerText = "STAGE 1";
                    startBtn.style.display = 'block'; 
                    inputArea.style.display = 'none';
                }, 1000);
            } catch(e) { alert("Error"); saveBtn.innerText = "TRY AGAIN"; }
        });

        // 遊戲控制器 (D-Pad & Fire)
        window.addEventListener('keydown', e => { keys[e.key] = true; if(e.code==='Space'&&gameRunning) shoot(player); });
        window.addEventListener('keyup', e => keys[e.key] = false);

        document.querySelectorAll('.control-btn').forEach(btn => {
            const handlePress = (e) => {
                if(e.cancelable) e.preventDefault(); // 控制器依然需要阻止預設行為(防止捲動)
                const key = btn.getAttribute('data-key');
                keys[key] = true;
                btn.classList.add('pressed');
                if (key === 'Space' && gameRunning) shoot(player);
            };
            const handleRelease = (e) => {
                if(e.cancelable) e.preventDefault();
                keys[btn.getAttribute('data-key')] = false;
                btn.classList.remove('pressed');
            };
            btn.addEventListener('touchstart', handlePress, {passive: false});
            btn.addEventListener('touchend', handleRelease, {passive: false});
            btn.addEventListener('mousedown', handlePress);
            btn.addEventListener('mouseup', handleRelease);
        });

        // --- 核心迴圈 ---
        function update() {
            frameCount++;
            let nextX = player.x, nextY = player.y;
            player.moving = false;
            if (keys['ArrowUp']) { player.dir = DIR.UP; nextY -= player.speed; player.moving = true; }
            else if (keys['ArrowDown']) { player.dir = DIR.DOWN; nextY += player.speed; player.moving = true; }
            else if (keys['ArrowLeft']) { player.dir = DIR.LEFT; nextX -= player.speed; player.moving = true; }
            else if (keys['ArrowRight']) { player.dir = DIR.RIGHT; nextX += player.speed; player.moving = true; }

            if (player.moving && !checkWallCollision(nextX, nextY, player.size)) {
                player.x = nextX; player.y = nextY;
            }

            bullets.forEach((b, i) => {
                b.x += b.vx; b.y += b.vy;
                if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) { bullets.splice(i, 1); return; }
                for (let j = 0; j < walls.length; j++) {
                    if (rectIntersect(b, walls[j])) { walls.splice(j, 1); bullets.splice(i, 1); return; }
                }
                if (base.alive && rectIntersect(b, base)) { base.alive = false; gameOver(); }
            });

            enemySpawnTimer++;
            if (enemySpawnTimer > 120) { spawnEnemy(); enemySpawnTimer = 0; }
            enemies.forEach((e, i) => {
                e.moveTimer++;
                if (e.moveTimer > 60) { e.dir = Math.floor(Math.random()*4); e.moveTimer = 0; if(Math.random()>0.7) shoot(e); }
                let ex = e.x, ey = e.y;
                if (e.dir === DIR.UP) ey -= e.speed; if (e.dir === DIR.DOWN) ey += e.speed;
                if (e.dir === DIR.LEFT) ex -= e.speed; if (e.dir === DIR.RIGHT) ex += e.speed;
                if (!checkWallCollision(ex, ey, e.size)) { e.x = ex; e.y = ey; }
                
                bullets.forEach((b, bi) => {
                    if (b.owner === 'player' && rectIntersect(b, e)) { enemies.splice(i, 1); bullets.splice(bi, 1); score += 100; }
                });
                if (rectIntersect(player, e)) gameOver();
            });
            bullets.forEach(b => { if (b.owner === 'enemy' && rectIntersect(b, player)) gameOver(); });
        }

        function draw() {
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = base.alive ? '#b71c1c' : '#555'; ctx.fillRect(base.x, base.y, base.size, base.size);
            ctx.fillStyle = '#b71c1c'; walls.forEach(w => { 
                ctx.fillRect(w.x+1, w.y+1, w.size-2, w.size-2); 
                ctx.fillStyle='#d32f2f'; ctx.fillRect(w.x+4,w.y+4,w.size/2,w.size/2); ctx.fillStyle='#b71c1c';
            });
            drawTank(ctx, player);
            enemies.forEach(e => drawTank(ctx, e));
            ctx.fillStyle = 'white'; bullets.forEach(b => ctx.fillRect(b.x, b.y, b.size, b.size));
            ctx.fillStyle = 'white'; ctx.font = '16px Courier New'; ctx.fillText(`SC: ${score}`, 5, 15);
        }

        function drawTank(ctx, t) {
            ctx.fillStyle = t.color || '#ccc'; ctx.fillRect(t.x, t.y, t.size, t.size);
            ctx.fillStyle = '#000'; 
            const s = t.size, cx = t.x + s/2, cy = t.y + s/2, L = s/2, W = s/5;
            if(t.dir===DIR.UP) ctx.fillRect(cx-W/2, cy-L, W, L);
            if(t.dir===DIR.DOWN) ctx.fillRect(cx-W/2, cy, W, L);
            if(t.dir===DIR.LEFT) ctx.fillRect(cx-L, cy-W/2, L, W);
            if(t.dir===DIR.RIGHT) ctx.fillRect(cx, cy-W/2, L, W);
        }

        function shoot(shooter) {
            const myBullets = bullets.filter(b => b.owner === (shooter===player?'player':'enemy'));
            if (myBullets.length > 0 && shooter === player) return;
            let vx=0, vy=0, s = shooter.size * 0.25;
            if (shooter.dir === DIR.UP) vy = -s; if (shooter.dir === DIR.DOWN) vy = s;
            if (shooter.dir === DIR.LEFT) vx = -s; if (shooter.dir === DIR.RIGHT) vx = s;
            bullets.push({ x: shooter.x+shooter.size/2-3, y: shooter.y+shooter.size/2-3, size: 6, vx, vy, owner: shooter===player?'player':'enemy' });
        }

        function spawnEnemy() {
            const s = player.size;
            enemies.push({ x: (Math.random()*(canvas.width-s)), y: 0, size: s, speed: s*0.05, dir: DIR.DOWN, moveTimer: 0 });
        }

        function checkWallCollision(x, y, s) {
            if (x < 0 || x + s > canvas.width || y < 0 || y + s > canvas.height) return true;
            for (let w of walls) if (rectIntersect({x,y,size:s}, w, 2)) return true;
            if (base.alive && rectIntersect({x,y,size:s}, base)) return true;
            return false;
        }

        function rectIntersect(r1, r2, p=0) {
            return !(r2.x+p > r1.x+r1.size-p || r2.x+r2.size-p < r1.x+p || r2.y+p > r1.y+r1.size-p || r2.y+r2.size-p < r1.y+p);
        }

        function animate() {
            if (!gameRunning) return;
            update(); draw();
            animationId = requestAnimationFrame(animate);
        }

        function gameOver() {
            gameRunning = false; cancelAnimationFrame(animationId);
            statusText.innerText = "GAME OVER";
            finalScoreText.innerText = `SCORE: ${score}`;
            finalScoreText.style.display = 'block'; inputArea.style.display = 'block';
            startBtn.style.display = 'none'; uiLayer.classList.add('active');
            loadLeaderboard();
        }

        async function loadLeaderboard() {
            miniLeaderboard.innerHTML = "Loading...";
            try {
                const q = query(collection(db, "leaderboard"), orderBy("score", "desc"), limit(3));
                const snap = await getDocs(q);
                let html = "";
                snap.forEach(d => html += `<div>${d.data().name}: ${d.data().score}</div>`);
                miniLeaderboard.innerHTML = html || "No Data";
            } catch (e) { miniLeaderboard.innerHTML = "Err"; }
        }
        loadLeaderboard();

    </script>
</body>
</html>
