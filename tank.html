<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Milo TANK 1990 (Fixed)</title>
    <style>
        /* 1. 鎖死整個頁面，禁止捲動 */
        html, body {
            position: fixed; 
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #111;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden; /* 隱藏所有捲軸 */
            
            /* 讓內容垂直水平置中 */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;

            /* 禁止選取與原生觸控行為 */
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; 
        }

        /* 標題 */
        h1 {
            font-size: 20px;
            color: #e69138;
            margin: 5px 0;
            flex-shrink: 0; /* 防止標題被壓縮 */
            text-shadow: 2px 2px #000;
        }

        /* 遊戲主容器 */
        #game-wrapper {
            position: relative;
            background-color: #000;
            border: 4px solid #555;
            /* 陰影增加立體感 */
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            flex-shrink: 0; 
        }

        canvas {
            display: block;
            image-rendering: pixelated;
        }

        /* UI 層 (開始畫面、結束畫面) */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            z-index: 20;
        }
        #ui-layer.active { display: flex; }

        /* 手機控制器區域 */
        #mobile-controls {
            display: flex;
            width: 100%;
            max-width: 500px; /* 限制按鈕區最大寬度 */
            justify-content: space-between;
            padding: 10px 20px;
            box-sizing: border-box;
            flex-shrink: 0; /* 防止被擠壓 */
            margin-bottom: 10px;
        }

        /* 十字鍵佈局 */
        .d-pad {
            display: grid;
            grid-template-columns: 50px 50px 50px;
            grid-template-rows: 45px 45px;
            gap: 4px;
        }

        .control-btn {
            background: #444;
            border: 2px solid #777;
            border-radius: 6px;
            color: #ccc;
            font-size: 18px;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 3px 0 #222;
            cursor: pointer;
        }
        .control-btn:active, .control-btn.pressed {
            background: #666;
            transform: translateY(3px);
            box-shadow: none;
        }

        /* 針對十字鍵的位置設定 */
        #btn-up { grid-column: 2; grid-row: 1; }
        #btn-left { grid-column: 1; grid-row: 2; }
        #btn-down { grid-column: 2; grid-row: 2; }
        #btn-right { grid-column: 3; grid-row: 2; }

        /* 發射鍵 */
        #fire-btn {
            width: 70px; height: 70px;
            border-radius: 50%;
            background: #b71c1c;
            border: 2px solid #e57373;
            color: white;
            font-weight: bold;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 4px 0 #7f0000;
            align-self: center;
        }
        #fire-btn:active, #fire-btn.pressed {
            transform: translateY(4px);
            box-shadow: none;
        }

        /* 輸入框與按鈕 */
        input { 
            padding: 8px; font-size: 16px; border: 2px solid #e69138; 
            background: #222; color: white; width: 60%; text-align: center; 
            font-family: 'Courier New'; 
            /* 讓輸入框可以被選取，否則 body 的 user-select: none 會導致無法輸入 */
            user-select: text; 
            -webkit-user-select: text;
        }
        button.game-btn { 
            padding: 10px 20px; font-size: 16px; background: #e69138; color: black; 
            border: none; margin-top: 15px; font-family: 'Courier New'; font-weight: bold; 
        }

        /* 排行榜 (讓它變成彈出視窗或僅在結束時顯示，避免佔用遊戲空間) */
        #leaderboard-overlay {
            margin-top: 10px;
            font-size: 12px;
            color: #888;
        }
    </style>
</head>
<body>

    <h1>Milo TANK 1990</h1>
    
    <div id="game-wrapper">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui-layer" class="active">
            <h2 id="status-text" style="color:#e69138; font-size:24px;">STAGE 1</h2>
            <h3 id="final-score" style="display:none">SCORE: 0</h3>
            
            <div id="input-area" style="display:none; text-align:center; width: 100%;">
                <input type="text" id="player-name" placeholder="NAME" maxlength="8">
                <br>
                <button id="save-btn" class="game-btn">SAVE</button>
            </div>
            
            <button id="start-btn" class="game-btn">START</button>

            <div id="leaderboard-overlay">
                <p>--- TOP 3 ---</p>
                <div id="mini-leaderboard">Loading...</div>
            </div>
        </div>
    </div>

    <div id="mobile-controls">
        <div class="d-pad">
            <div id="btn-up" class="control-btn" data-key="ArrowUp">▲</div>
            <div id="btn-left" class="control-btn" data-key="ArrowLeft">◀</div>
            <div id="btn-down" class="control-btn" data-key="ArrowDown">▼</div>
            <div id="btn-right" class="control-btn" data-key="ArrowRight">▶</div>
        </div>
        <div id="fire-btn" class="control-btn" data-key="Space">FIRE</div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDcHWsk6ffYC1XyKIga8GpHok_jUyPcNQc",
            authDomain: "milo-game-d238c.firebaseapp.com",
            projectId: "milo-game-d238c",
            storageBucket: "milo-game-d238c.firebasestorage.app",
            messagingSenderId: "64418915608",
            appId: "1:64418915608:web:7a4c51bab0afcad8756a6d"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // --- 核心變數 ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const BLOCK_SIZE = 32; 

        // --- 關鍵修改：智慧型畫面縮放 (Smart Resize) ---
        function resizeGame() {
            // 取得視窗總空間
            const winW = window.innerWidth;
            const winH = window.innerHeight;

            // 預留空間給標題(約40px) 和 控制器(約120px)
            // 這是避免遊戲畫面太大，把按鈕擠出螢幕外
            const availableH = winH - 160; 
            const availableW = winW - 20; // 左右留點邊距

            // 找出「寬度」和「高度」哪個限制比較大，取最小值來決定遊戲大小
            // 我們希望遊戲保持正方形 (1:1)
            let gameSize = Math.min(availableW, availableH);

            // 限制最大尺寸 (不要超過 520px，不然像素會太粗)
            if (gameSize > 520) gameSize = 520;

            // 確保是 BLOCK_SIZE 的倍數 (防止破圖)
            const cols = Math.floor(gameSize / BLOCK_SIZE);
            const finalSize = cols * BLOCK_SIZE;

            canvas.width = finalSize;
            canvas.height = finalSize;
            
            // 如果遊戲還沒開始或需要重繪，這裡可以觸發重繪
            if (!gameRunning) {
                ctx.fillStyle = "#000";
                ctx.fillRect(0,0, canvas.width, canvas.height);
            }
        }

        // 初始化與監聽轉向
        resizeGame();
        window.addEventListener('resize', resizeGame);

        // UI 元素
        const uiLayer = document.getElementById('ui-layer');
        const startBtn = document.getElementById('start-btn');
        const saveBtn = document.getElementById('save-btn');
        const statusText = document.getElementById('status-text');
        const inputArea = document.getElementById('input-area');
        const finalScoreText = document.getElementById('final-score');
        const playerNameInput = document.getElementById('player-name');
        const miniLeaderboard = document.getElementById('mini-leaderboard');

        let gameRunning = false;
        let score = 0;
        let animationId;
        let frameCount = 0;

        let player;
        let bullets = [];
        let enemies = [];
        let walls = [];
        let base = {};
        let enemySpawnTimer = 0;
        const DIR = { UP: 0, RIGHT: 1, DOWN: 2, LEFT: 3 };
        const keys = {};

        // --- 遊戲邏輯 (與之前相同，但適配 resize) ---
        function resetGame() {
            // 根據當前 canvas 大小重新計算比例
            const size = canvas.width / 13; 
            
            player = { 
                x: size * 4, y: canvas.height - size, 
                size: size, speed: size * 0.1, 
                dir: DIR.UP, moving: false,
                color: '#e69138'
            };
            base = { x: canvas.width / 2 - size / 2, y: canvas.height - size, size: size, alive: true };

            bullets = [];
            enemies = [];
            walls = [];
            score = 0;
            enemySpawnTimer = 0;
            createMap(size);
        }

        function createMap(size) {
            walls.push({x: base.x - size, y: base.y, size: size});
            walls.push({x: base.x - size, y: base.y - size, size: size});
            walls.push({x: base.x, y: base.y - size, size: size});
            walls.push({x: base.x + size, y: base.y - size, size: size});
            walls.push({x: base.x + size, y: base.y, size: size});

            for(let i=0; i<15; i++) {
                let wx = Math.floor(Math.random() * 13) * size;
                let wy = Math.floor(Math.random() * 10) * size;
                if (wy < size * 2) continue; 
                walls.push({x: wx, y: wy, size: size});
            }
        }

        // --- 控制輸入處理 (防止預設行為) ---
        
        // 鍵盤
        window.addEventListener('keydown', e => {
            keys[e.key] = true;
            if (e.code === 'Space' && gameRunning) shoot(player);
        });
        window.addEventListener('keyup', e => keys[e.key] = false);

        // 觸控按鈕
        document.querySelectorAll('.control-btn').forEach(btn => {
            const handlePress = (e) => {
                // 關鍵：阻止瀏覽器預設行為（如雙擊放大、捲動）
                if(e.cancelable) e.preventDefault(); 
                
                const key = btn.getAttribute('data-key');
                keys[key] = true;
                btn.classList.add('pressed');
                if (key === 'Space' && gameRunning) shoot(player);
            };
            const handleRelease = (e) => {
                if(e.cancelable) e.preventDefault();
                keys[btn.getAttribute('data-key')] = false;
                btn.classList.remove('pressed');
            };

            // 使用 passive: false 才能呼叫 preventDefault
            btn.addEventListener('touchstart', handlePress, {passive: false});
            btn.addEventListener('touchend', handleRelease, {passive: false});
            // 兼容滑鼠
            btn.addEventListener('mousedown', handlePress);
            btn.addEventListener('mouseup', handleRelease);
        });

        // --- 繪圖與更新 (簡化版) ---
        function update() {
            frameCount++;
            // 玩家移動
            let nextX = player.x, nextY = player.y;
            player.moving = false;
            if (keys['ArrowUp']) { player.dir = DIR.UP; nextY -= player.speed; player.moving = true; }
            else if (keys['ArrowDown']) { player.dir = DIR.DOWN; nextY += player.speed; player.moving = true; }
            else if (keys['ArrowLeft']) { player.dir = DIR.LEFT; nextX -= player.speed; player.moving = true; }
            else if (keys['ArrowRight']) { player.dir = DIR.RIGHT; nextX += player.speed; player.moving = true; }

            if (player.moving && !checkWallCollision(nextX, nextY, player.size)) {
                player.x = nextX; player.y = nextY;
            }

            // 子彈
            bullets.forEach((b, i) => {
                b.x += b.vx; b.y += b.vy;
                if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) { bullets.splice(i, 1); return; }
                for (let j = 0; j < walls.length; j++) {
                    if (rectIntersect(b, walls[j])) { walls.splice(j, 1); bullets.splice(i, 1); return; }
                }
                if (base.alive && rectIntersect(b, base)) { base.alive = false; gameOver(); }
            });

            // 敵人
            enemySpawnTimer++;
            if (enemySpawnTimer > 150) { spawnEnemy(); enemySpawnTimer = 0; }
            enemies.forEach((e, i) => {
                e.moveTimer++;
                if (e.moveTimer > 60) { e.dir = Math.floor(Math.random()*4); e.moveTimer = 0; if(Math.random()>0.6) shoot(e); }
                let ex = e.x, ey = e.y;
                if (e.dir === DIR.UP) ey -= e.speed; if (e.dir === DIR.DOWN) ey += e.speed;
                if (e.dir === DIR.LEFT) ex -= e.speed; if (e.dir === DIR.RIGHT) ex += e.speed;
                if (!checkWallCollision(ex, ey, e.size)) { e.x = ex; e.y = ey; }
                
                bullets.forEach((b, bi) => {
                    if (b.owner === 'player' && rectIntersect(b, e)) { enemies.splice(i, 1); bullets.splice(bi, 1); score += 100; }
                });
                if (rectIntersect(player, e)) gameOver();
            });
            // 敵人子彈打玩家
            bullets.forEach(b => { if (b.owner === 'enemy' && rectIntersect(b, player)) gameOver(); });
        }

        function draw() {
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Base
            ctx.fillStyle = base.alive ? '#b71c1c' : '#555'; ctx.fillRect(base.x, base.y, base.size, base.size);
            // Walls
            ctx.fillStyle = '#b71c1c'; walls.forEach(w => { 
                ctx.fillRect(w.x+1, w.y+1, w.size-2, w.size-2); 
                ctx.fillStyle='#d32f2f'; ctx.fillRect(w.x+4,w.y+4,w.size/2,w.size/2); ctx.fillStyle='#b71c1c';
            });
            // Player & Enemy
            drawTank(ctx, player);
            enemies.forEach(e => drawTank(ctx, e));
            // Bullets
            ctx.fillStyle = 'white'; bullets.forEach(b => ctx.fillRect(b.x, b.y, b.size, b.size));
            // Score
            ctx.fillStyle = 'white'; ctx.font = '16px Courier New'; ctx.fillText(`SC: ${score}`, 5, 15);
        }

        function drawTank(ctx, t) {
            ctx.fillStyle = t.color || '#ccc';
            // 簡單繪製坦克示意
            ctx.fillRect(t.x, t.y, t.size, t.size);
            ctx.fillStyle = '#000'; // 砲管方向
            const s = t.size, cx = t.x + s/2, cy = t.y + s/2, L = s/2, W = s/5;
            if(t.dir===DIR.UP) ctx.fillRect(cx-W/2, cy-L, W, L);
            if(t.dir===DIR.DOWN) ctx.fillRect(cx-W/2, cy, W, L);
            if(t.dir===DIR.LEFT) ctx.fillRect(cx-L, cy-W/2, L, W);
            if(t.dir===DIR.RIGHT) ctx.fillRect(cx, cy-W/2, L, W);
        }

        function shoot(shooter) {
            const myBullets = bullets.filter(b => b.owner === (shooter===player?'player':'enemy'));
            if (myBullets.length > 0 && shooter === player) return;
            let vx=0, vy=0, s = shooter.size * 0.25;
            if (shooter.dir === DIR.UP) vy = -s; if (shooter.dir === DIR.DOWN) vy = s;
            if (shooter.dir === DIR.LEFT) vx = -s; if (shooter.dir === DIR.RIGHT) vx = s;
            bullets.push({ x: shooter.x+shooter.size/2-3, y: shooter.y+shooter.size/2-3, size: 6, vx, vy, owner: shooter===player?'player':'enemy' });
        }

        function spawnEnemy() {
            const s = player.size;
            enemies.push({ x: (Math.random()*(canvas.width-s)), y: 0, size: s, speed: s*0.05, dir: DIR.DOWN, moveTimer: 0 });
        }

        function checkWallCollision(x, y, s) {
            if (x < 0 || x + s > canvas.width || y < 0 || y + s > canvas.height) return true;
            for (let w of walls) if (rectIntersect({x,y,size:s}, w, 2)) return true;
            if (base.alive && rectIntersect({x,y,size:s}, base)) return true;
            return false;
        }

        function rectIntersect(r1, r2, p=0) {
            return !(r2.x+p > r1.x+r1.size-p || r2.x+r2.size-p < r1.x+p || r2.y+p > r1.y+r1.size-p || r2.y+r2.size-p < r1.y+p);
        }

        function animate() {
            if (!gameRunning) return;
            update(); draw();
            animationId = requestAnimationFrame(animate);
        }

        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationId);
            statusText.innerText = "GAME OVER";
            finalScoreText.innerText = `SCORE: ${score}`;
            finalScoreText.style.display = 'block'; inputArea.style.display = 'block';
            startBtn.style.display = 'none'; uiLayer.classList.add('active');
            loadLeaderboard(); // 結束時更新排行榜
        }

        startBtn.addEventListener('click', () => {
            resetGame(); gameRunning = true; uiLayer.classList.remove('active');
            inputArea.style.display = 'none'; finalScoreText.style.display = 'none'; animate();
        });

        saveBtn.addEventListener('click', async () => {
            const name = playerNameInput.value || "AAA";
            saveBtn.innerText = "...";
            try {
                await addDoc(collection(db, "leaderboard"), { name, score, date: new Date() });
                await loadLeaderboard();
                saveBtn.innerText = "SAVE"; statusText.innerText = "STAGE 1";
                startBtn.style.display = 'block'; inputArea.style.display = 'none';
            } catch(e) { alert("Error"); }
        });

        async function loadLeaderboard() {
            miniLeaderboard.innerHTML = "Loading...";
            try {
                const q = query(collection(db, "leaderboard"), orderBy("score", "desc"), limit(3));
                const snap = await getDocs(q);
                let html = "";
                snap.forEach(d => html += `<div>${d.data().name}: ${d.data().score}</div>`);
                miniLeaderboard.innerHTML = html || "No Data";
            } catch (e) { miniLeaderboard.innerHTML = "Err"; }
        }
        loadLeaderboard();
    </script>
</body>
</html>
